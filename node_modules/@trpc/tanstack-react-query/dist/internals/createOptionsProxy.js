'use strict';

var client = require('@trpc/client');
var server = require('@trpc/server');
var infiniteQueryOptions = require('./infiniteQueryOptions.js');
var mutationOptions = require('./mutationOptions.js');
var queryOptions = require('./queryOptions.js');
var subscriptionOptions = require('./subscriptionOptions.js');
var utils = require('./utils.js');

/**
 * Create a typed proxy from your router types. Can also be used on the server.
 *
 * @see https://trpc.io/docs/client/tanstack-react-query/setup#3b-setup-without-react-context
 * @see https://trpc.io/docs/client/tanstack-react-query/server-components#5-create-a-trpc-caller-for-server-components
 */ function createTRPCOptionsProxy(opts) {
    const callIt = (type)=>{
        return (path, input, trpcOpts)=>{
            if ('router' in opts) {
                return Promise.resolve(utils.unwrapLazyArg(opts.ctx)).then((ctx)=>server.callTRPCProcedure({
                        router: opts.router,
                        path: path,
                        getRawInput: async ()=>input,
                        ctx: ctx,
                        type: type,
                        signal: undefined
                    }));
            }
            const untypedClient = opts.client instanceof client.TRPCUntypedClient ? opts.client : client.getUntypedClient(opts.client);
            return untypedClient[type](path, input, trpcOpts);
        };
    };
    return server.createTRPCRecursiveProxy(({ args, path: _path })=>{
        const path = [
            ..._path
        ];
        const utilName = path.pop();
        const [arg1, arg2] = args;
        const contextMap = {
            '~types': undefined,
            pathKey: ()=>{
                return utils.getQueryKeyInternal(path);
            },
            pathFilter: ()=>{
                return {
                    ...arg1,
                    queryKey: utils.getQueryKeyInternal(path)
                };
            },
            queryOptions: ()=>{
                return queryOptions.trpcQueryOptions({
                    input: arg1,
                    opts: arg2,
                    path,
                    queryClient: opts.queryClient,
                    queryKey: utils.getQueryKeyInternal(path, arg1, 'query'),
                    query: callIt('query')
                });
            },
            queryKey: ()=>{
                return utils.getQueryKeyInternal(path, arg1, 'query');
            },
            queryFilter: ()=>{
                return {
                    ...arg2,
                    queryKey: utils.getQueryKeyInternal(path, arg1, 'query')
                };
            },
            infiniteQueryOptions: ()=>{
                return infiniteQueryOptions.trpcInfiniteQueryOptions({
                    input: arg1,
                    opts: arg2,
                    path,
                    queryClient: opts.queryClient,
                    queryKey: utils.getQueryKeyInternal(path, arg1, 'infinite'),
                    query: callIt('query')
                });
            },
            infiniteQueryKey: ()=>{
                return utils.getQueryKeyInternal(path, arg1, 'infinite');
            },
            infiniteQueryFilter: ()=>{
                return {
                    ...arg2,
                    queryKey: utils.getQueryKeyInternal(path, arg1, 'infinite')
                };
            },
            mutationOptions: ()=>{
                return mutationOptions.trpcMutationOptions({
                    opts: arg1,
                    path,
                    queryClient: opts.queryClient,
                    mutate: callIt('mutation'),
                    overrides: opts.overrides?.mutations
                });
            },
            mutationKey: ()=>{
                return utils.getMutationKeyInternal(path);
            },
            subscriptionOptions: ()=>{
                return subscriptionOptions.trpcSubscriptionOptions({
                    opts: arg2,
                    path,
                    queryKey: utils.getQueryKeyInternal(path, arg1, 'any'),
                    subscribe: callIt('subscription')
                });
            }
        };
        return contextMap[utilName]();
    });
}

exports.createTRPCOptionsProxy = createTRPCOptionsProxy;
