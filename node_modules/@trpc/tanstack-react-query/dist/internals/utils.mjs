import { skipToken } from '@tanstack/react-query';
import { isObject, isFunction } from '@trpc/server/unstable-core-do-not-import';

/**
 * @internal
 */ function createTRPCOptionsResult(value) {
    const path = value.path.join('.');
    return {
        path
    };
}
/**
 * @internal
 */ function getClientArgs(queryKey, opts, infiniteParams) {
    const path = queryKey[0];
    let input = queryKey[1]?.input;
    if (infiniteParams) {
        input = {
            ...input ?? {},
            ...infiniteParams.pageParam !== undefined ? {
                cursor: infiniteParams.pageParam
            } : {},
            direction: infiniteParams.direction
        };
    }
    return [
        path.join('.'),
        input,
        opts?.trpc
    ];
}
/**
 * @internal
 */ async function buildQueryFromAsyncIterable(asyncIterable, queryClient, queryKey) {
    const queryCache = queryClient.getQueryCache();
    const query = queryCache.build(queryClient, {
        queryKey
    });
    query.setState({
        data: [],
        status: 'success'
    });
    const aggregate = [];
    for await (const value of asyncIterable){
        aggregate.push(value);
        query.setState({
            data: [
                ...aggregate
            ]
        });
    }
    return aggregate;
}
/**
 * To allow easy interactions with groups of related queries, such as
 * invalidating all queries of a router, we use an array as the path when
 * storing in tanstack query.
 *
 * @internal
 */ function getQueryKeyInternal(path, input, type) {
    // Construct a query key that is easy to destructure and flexible for
    // partial selecting etc.
    // https://github.com/trpc/trpc/issues/3128
    // some parts of the path may be dot-separated, split them up
    const splitPath = path.flatMap((part)=>part.split('.'));
    if (!input && (!type || type === 'any')) {
        // this matches also all mutations (see `getMutationKeyInternal`)
        // for `utils.invalidate()` to match all queries (including vanilla react-query)
        // we don't want nested array if path is empty, i.e. `[]` instead of `[[]]`
        return splitPath.length ? [
            splitPath
        ] : [];
    }
    if (type === 'infinite' && isObject(input) && ('direction' in input || 'cursor' in input)) {
        const { cursor: _, direction: __, ...inputWithoutCursorAndDirection } = input;
        return [
            splitPath,
            {
                input: inputWithoutCursorAndDirection,
                type: 'infinite'
            }
        ];
    }
    return [
        splitPath,
        {
            ...typeof input !== 'undefined' && input !== skipToken && {
                input: input
            },
            ...type && type !== 'any' && {
                type: type
            }
        }
    ];
}
/**
 * @internal
 */ function getMutationKeyInternal(path) {
    // some parts of the path may be dot-separated, split them up
    const splitPath = path.flatMap((part)=>part.split('.'));
    return splitPath.length ? [
        splitPath
    ] : [];
}
/**
 * @internal
 */ function unwrapLazyArg(valueOrLazy) {
    return isFunction(valueOrLazy) ? valueOrLazy() : valueOrLazy;
}

export { buildQueryFromAsyncIterable, createTRPCOptionsResult, getClientArgs, getMutationKeyInternal, getQueryKeyInternal, unwrapLazyArg };
