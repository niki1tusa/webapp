import { hashKey, skipToken } from '@tanstack/react-query';
import * as React from 'react';
import { createTRPCOptionsResult } from './utils.mjs';

/**
 * @internal
 */ const trpcSubscriptionOptions = (args)=>{
    const { subscribe, path, queryKey, opts = {} } = args;
    const input = queryKey[1]?.input;
    const enabled = 'enabled' in opts ? !!opts.enabled : input !== skipToken;
    const _subscribe = (innerOpts)=>{
        return subscribe(path.join('.'), input ?? undefined, innerOpts);
    };
    return {
        ...opts,
        enabled,
        subscribe: _subscribe,
        queryKey,
        trpc: createTRPCOptionsResult({
            path
        })
    };
};
function useSubscription(opts) {
    const optsRef = React.useRef(opts);
    optsRef.current = opts;
    const trackedProps = React.useRef(new Set([]));
    const addTrackedProp = React.useCallback((key)=>{
        trackedProps.current.add(key);
    }, []);
    const currentSubscriptionRef = React.useRef(()=>{
    // noop
    });
    const reset = React.useCallback(()=>{
        // unsubscribe from the previous subscription
        currentSubscriptionRef.current?.();
        updateState(getInitialState);
        if (!opts.enabled) {
            return;
        }
        const subscription = opts.subscribe({
            onStarted: ()=>{
                optsRef.current.onStarted?.();
                updateState((prev)=>({
                        ...prev,
                        status: 'pending',
                        error: null
                    }));
            },
            onData: (data)=>{
                optsRef.current.onData?.(data);
                updateState((prev)=>({
                        ...prev,
                        status: 'pending',
                        data,
                        error: null
                    }));
            },
            onError: (error)=>{
                optsRef.current.onError?.(error);
                updateState((prev)=>({
                        ...prev,
                        status: 'error',
                        error
                    }));
            },
            onConnectionStateChange: (result)=>{
                updateState((prev)=>{
                    switch(result.state){
                        case 'connecting':
                            return {
                                ...prev,
                                status: 'connecting',
                                error: result.error
                            };
                        case 'pending':
                            // handled in onStarted
                            return prev;
                        case 'idle':
                            return {
                                ...prev,
                                status: 'idle',
                                data: undefined,
                                error: null
                            };
                    }
                });
            }
        });
        currentSubscriptionRef.current = ()=>{
            subscription.unsubscribe();
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        hashKey(opts.queryKey),
        opts.enabled
    ]);
    const getInitialState = React.useCallback(()=>{
        return opts.enabled ? {
            data: undefined,
            error: null,
            status: 'connecting',
            reset
        } : {
            data: undefined,
            error: null,
            status: 'idle',
            reset
        };
    }, [
        opts.enabled,
        reset
    ]);
    const resultRef = React.useRef(getInitialState());
    const [state, setState] = React.useState(trackResult(resultRef.current, addTrackedProp));
    state.reset = reset;
    const updateState = React.useCallback((callback)=>{
        const prev = resultRef.current;
        const next = resultRef.current = callback(prev);
        let shouldUpdate = false;
        for (const key of trackedProps.current){
            if (prev[key] !== next[key]) {
                shouldUpdate = true;
                break;
            }
        }
        if (shouldUpdate) {
            setState(trackResult(next, addTrackedProp));
        }
    }, [
        addTrackedProp
    ]);
    React.useEffect(()=>{
        if (!opts.enabled) {
            return;
        }
        reset();
        return ()=>{
            currentSubscriptionRef.current?.();
        };
    }, [
        reset,
        opts.enabled
    ]);
    return state;
}
function trackResult(result, onTrackResult) {
    const trackedResult = new Proxy(result, {
        get (target, prop) {
            onTrackResult(prop);
            return target[prop];
        }
    });
    return trackedResult;
}

export { trpcSubscriptionOptions, useSubscription };
